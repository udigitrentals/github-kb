
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KB Probe</title>
<style>
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:#0b0b0b; color:#ececec; padding:20px; }
  h1 { font-size: 20px; }
  .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-bottom: 12px; }
  input { background:#121212; border:1px solid #333; color:#ececec; padding:8px 10px; border-radius:8px; min-width: 280px; }
  button { background:#C21C1C; color:#fff; border:none; padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:600; }
  code, pre { background:#121212; color:#E1BC56; padding:10px; border-radius:10px; display:block; white-space:pre-wrap; word-break:break-word; }
  .ok { color:#19d27c; }
  .err { color:#ff6961; }
  table { width:100%; border-collapse: collapse; margin-top:10px; }
  td, th { padding:8px; border-bottom:1px solid #333; }
  .small { opacity: .8; font-size: 12px; }
</style>
</head>
<body>
<h1>KB Diagnostic Probe</h1>
<div class="row">
  <label>Local base: <input id="base" placeholder="/docs" value="/docs"/></label>
  <label>Raw base: <input id="rawBase" placeholder="https://raw.githubusercontent.com/ORG/REPO/main/docs" value=""/></label>
  <button id="go">Probe</button>
</div>
<div class="small">Tip: you can also pass <code>?base=/docs&rawBase=https://raw.githubusercontent.com/udigitrentals/github-kb/main/docs</code></div>
<div id="out"></div>

<script>
const qs = new URLSearchParams(location.search);
const baseInput = document.getElementById('base');
const rawInput  = document.getElementById('rawBase');
if (qs.get('base')) baseInput.value = qs.get('base');
if (qs.get('rawBase')) rawInput.value = qs.get('rawBase');

function candidates(base, raw, file) {
  const out = [];
  if (base) out.push(`${base.replace(/\/$/, '')}/${file}`);
  out.push(`/${file}`);
  if (raw) out.push(`${raw.replace(/\/$/, '')}/${file}`);
  return out;
}

async function tryOne(url) {
  const t0 = performance.now();
  try {
    const res = await fetch(url, {cache:'no-store'});
    const text = await res.text();
    const dt = (performance.now()-t0).toFixed(1);
    if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
    let json; try { json = JSON.parse(text); } catch(parseErr) {
      throw new Error(`Parse error: ${parseErr.message}. First 200 chars: ${text.slice(0,200)}`);
    }
    return { ok:true, url, ms:dt, json };
  } catch (e) {
    return { ok:false, url, err:String(e) };
  }
}

function normSearch(j){ if (Array.isArray(j)) return j; if (j && typeof j==='object') return j.items||j.docs||j.search||j.results||j.index||[]; return []; }
function normReg(j){ if (Array.isArray(j)) return j; if (j && typeof j==='object') return j.registry||j.items||j.docs||[]; return []; }
function normX(j){ if (Array.isArray(j)) return {edges:j}; if (j && typeof j==='object'){ if (Array.isArray(j.edges)) return {edges:j.edges}; if (j.graph && Array.isArray(j.graph.edges)) return {edges:j.graph.edges}; if (Array.isArray(j.links)) return {edges:j.links}; if (Array.isArray(j.relations)) return {edges:j.relations}; } return {edges:[]}; }

function renderStatus(name, results, counts) {
  const best = results.find(r=>r.ok);
  const color = best ? 'ok' : 'err';
  return `<h3>${name}: <span class="${color}">${best ? 'OK' : 'FAILED'}</span></h3>
    <table>
      <tr><th>Attempt</th><th>Status</th><th>Detail</th></tr>
      ${results.map(r=>`<tr>
        <td><code>${r.url}</code></td>
        <td>${r.ok?'<span class="ok">200</span>':'<span class="err">ERR</span>'}</td>
        <td class="small">${r.ok? `${r.ms} ms; ${counts}` : r.err}</td>
      </tr>`).join('')}
    </table>`;
}

async function probe() {
  const out = document.getElementById('out');
  out.innerHTML = '<p>Probingâ€¦</p>';

  const base = baseInput.value.trim();
  const raw  = rawInput.value.trim();

  const files = {registry:'registry.json', search:'search.json', xlinks:'cross_links.json'};

  const regRes = await Promise.all(candidates(base, raw, files.registry).map(tryOne));
  const sRes   = await Promise.all(candidates(base, raw, files.search).map(tryOne));
  const xRes   = await Promise.all(candidates(base, raw, files.xlinks).map(tryOne));

  const regOK = regRes.find(r=>r.ok);
  const sOK   = sRes.find(r=>r.ok);
  const xOK   = xRes.find(r=>r.ok);

  let regCount = sCount = xCount = 0;
  if (regOK) regCount = normReg(regOK.json).length;
  if (sOK)   sCount   = normSearch(sOK.json).length;
  if (xOK)   xCount   = normX(xOK.json).edges.length;

  out.innerHTML = `
    ${renderStatus('registry.json', regRes, regCount + ' items')}
    ${renderStatus('search.json', sRes, sCount + ' docs')}
    ${renderStatus('cross_links.json', xRes, xCount + ' edges')}
    <h3>Summary</h3>
    <pre>${JSON.stringify({
      registry_items: regCount, search_docs: sCount, edges: xCount,
      resolved: {
        registry: regOK ? regOK.url : null,
        search:   sOK ? sOK.url : null,
        xlinks:   xOK ? xOK.url : null
      }
    }, null, 2)}</pre>
  `;
}

document.getElementById('go').addEventListener('click', probe);
</script>
</body>
</html>
