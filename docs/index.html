<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KB Live Viewer + Uploader + Probe</title>
<meta name="description" content="Drop Markdown to generate registry.json/search.json/cross_links.json, then probe/preview. Client-side only."/>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js" defer></script>
<style>
:root{
  --bg:#0b0b0b;--panel:#121212;--ink:#ececec;--muted:#a9a9a9;--accent:#E1BC56;--cta:#A90F0F;
  --ok:#1f9d55;--warn:#d39e00;--err:#c0392b;--radius:12px;--border:#1e1e1e;--shadow:0 10px 20px rgba(0,0,0,.25);
}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--ink);font:15px/1.5 system-ui,Segoe UI,Roboto,Arial}
header{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:16px 20px;background:#000;box-shadow:var(--shadow);position:sticky;top:0;z-index:5}
h1{margin:0;font-size:18px;letter-spacing:.2px}
small.muted{color:var(--muted)}
.container{max-width:1240px;margin:16px auto 24px;padding:0 16px}
.row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
.card{background:var(--panel);border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);padding:16px}
.btn{background:var(--cta);color:#fff;border:none;border-radius:10px;padding:10px 14px;font-weight:700;cursor:pointer}
.btn.secondary{background:#232323}
.btn.ghost{background:transparent;border:1px solid #333}
.badge{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px}
.badge.ok{background:rgba(31,157,85,.2);color:var(--ok)}
.badge.err{background:rgba(192,57,43,.2);color:var(--err)}
.badge.muted{background:#1b1b1b;color:#aaa}
input,textarea{background:#0f0f0f;color:var(--ink);border:1px solid #2f2f2f;border-radius:10px;padding:9px 10px}
code,pre{background:#0f0f0f;border:1px solid #2f2f2f;border-radius:10px;padding:10px;color:var(--accent)}
table{width:100%;border-collapse:collapse}
th,td{padding:8px;border-bottom:1px solid #272727;text-align:left}
.grid{display:grid;grid-template-columns:1.15fr .85fr;gap:16px}
@media(max-width:980px){.grid{grid-template-columns:1fr}}
.kv{display:grid;grid-template-columns:120px 1fr;gap:8px;margin-top:8px}
.hidden{display:none}
footer{opacity:.6;text-align:center;padding:24px}
.pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;border:1px solid #333;background:#0f0f0f;color:#bbb;font-size:12px}
.drop{border:2px dashed #3a3a3a;border-radius:14px;padding:18px;text-align:center;background:#0e0e0e}
.drop.drag{border-color:var(--accent);background:#151007}
.list{max-height:220px;overflow:auto;border:1px solid #222;border-radius:10px}
.item{padding:8px 12px;border-bottom:1px solid #1a1a1a;display:flex;align-items:center;gap:10px}
.item:last-child{border-bottom:none}
.small{font-size:12px}
section.hstack{display:grid;grid-template-columns:repeat(3,minmax(240px,1fr));gap:12px}
</style>
</head>
<body>
<header>
  <div><h1>KB Live Viewer <small class="muted">+ Uploader + Probe</small></h1></div>
  <div class="row">
    <button class="btn secondary" id="theme">Theme</button>
    <button class="btn ghost" id="reload">Reload</button>
  </div>
</header>

<div class="container grid">
  <!-- LEFT: INGESTOR -->
  <div class="card">
    <div class="row" style="justify-content:space-between">
      <div class="row">
        <span class="pill">Status: <span id="ingStatus" class="badge muted">Idle</span></span>
        <span class="pill">Files: <b id="fileCount">0</b></span>
        <span class="pill">Blocks: <b id="blockCount">0</b></span>
      </div>
      <div class="row">
        <button id="btnClear" class="btn ghost" title="Clear files">Clear</button>
      </div>
    </div>

    <div id="drop" class="drop" tabindex="0" style="margin-top:10px">
      <p><b>Drop Markdown files here</b> or <label for="file" class="pill" style="cursor:pointer">browse…</label></p>
      <input id="file" type="file" accept=".md,.markdown,.txt" multiple hidden />
      <p class="small muted">Lossless ingestion: headings, code fences, inline links preserved. We auto‑segment into search blocks.</p>
    </div>

    <div class="row" style="margin-top:12px">
      <input id="collection" type="text" placeholder="collection (e.g., kb)" value="kb" />
      <input id="baseUrl" type="text" placeholder="(optional) raw base for source_url" value="https://raw.githubusercontent.com/udigitrentals/github-kb/main/docs" />
    </div>

    <details style="margin-top:12px">
      <summary>Advanced: merge with existing JSONs</summary>
      <div class="row" style="margin-top:10px">
        <label>Upload existing <b>registry.json</b> &nbsp;<input id="existingRegistry" type="file" accept="application/json" /></label>
      </div>
      <div class="row">
        <label>Upload existing <b>search.json</b> &nbsp;<input id="existingSearch" type="file" accept="application/json" /></label>
      </div>
      <div class="row">
        <label>Upload existing <b>cross_links.json</b> &nbsp;<input id="existingCross" type="file" accept="application/json" /></label>
      </div>
      <div class="row" style="margin-top:10px">
        <label><input id="dedupe" type="checkbox" checked /> De‑duplicate by <code>id</code> and <code>slug</code></label>
        <label><input id="sanitize" type="checkbox" checked /> Sanitize conflict markers (<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>/<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>)</label>
      </div>
    </details>

    <div class="row" style="margin-top:12px">
      <button id="btnGenerate" class="btn" disabled>Generate JSONs</button>
      <button id="btnLoadViewer" class="btn secondary" disabled>Load into Viewer</button>
      <a id="zipLink" class="btn" download="kb_payload.zip" href="#" style="display:none">Download ZIP</a>
    </div>
    <p class="small muted" id="genMeta"></p>

    <div class="list" id="fileList" style="margin-top:8px"></div>

    <section class="card" style="margin-top:14px">
      <b>Preview (first 2 registry items)</b>
      <pre id="preview" class="small" style="white-space:pre-wrap;max-height:240px;overflow:auto"></pre>
    </section>
  </div>

  <!-- RIGHT: PROBE / VIEWER -->
  <div>
    <div class="card">
      <div class="row">
        <label>Local base&nbsp;<input id="base" placeholder="/docs" value="/docs"/></label>
        <label>Raw base&nbsp;<input id="rawBase" placeholder="https://raw.githubusercontent.com/ORG/REPO/main/docs" value=""/></label>
        <button class="btn" id="apply">Apply</button>
        <button class="btn ghost" id="clearCache">Clear cache</button>
        <button class="btn ghost" id="probe">Run Probe</button>
        <button class="btn" id="downloadAll">Download current JSONs</button>
      </div>
      <div class="kv">
        <div>Resolved:</div>
        <div id="resolved">—</div>
        <div>Status:</div>
        <div id="status">Waiting…</div>
      </div>
    </div>

    <section class="hstack">
      <div class="card">
        <h3>registry.json <span id="regStatus" class="badge muted">—</span></h3>
        <div id="regCount">—</div>
        <pre id="regPreview" class="hidden"></pre>
        <button class="btn ghost" id="toggleReg">Toggle preview</button>
      </div>
      <div class="card">
        <h3>search.json <span id="sStatus" class="badge muted">—</span></h3>
        <div id="sCount">—</div>
        <pre id="sPreview" class="hidden"></pre>
        <button class="btn ghost" id="toggleS">Toggle preview</button>
      </div>
      <div class="card">
        <h3>cross_links.json <span id="xStatus" class="badge muted">—</span></h3>
        <div id="xCount">—</div>
        <pre id="xPreview" class="hidden"></pre>
        <button class="btn ghost" id="toggleX">Toggle preview</button>
      </div>
    </section>

    <div class="card" style="margin-top:12px">
      <h3>Diagnostic Log</h3>
      <pre id="log" style="max-height:320px;overflow:auto"></pre>
    </div>
  </div>
</div>

<footer class="container">
  <small>Tip: you can pass <code>?base=/docs&rawBase=https://raw.githubusercontent.com/udigitrentals/github-kb/main/docs</code></small>
</footer>

<script>
// ------------- Theme & reload -------------
document.getElementById('theme').onclick = () => document.body.classList.toggle('light');
document.getElementById('reload').onclick = () => location.reload();

// ------------- Helpers -------------
const $$ = sel => document.querySelector(sel);
const logEl = $$('#log');
function log(){ const s = Array.from(arguments).map(a=>typeof a==='string'?a:JSON.stringify(a)).join(' '); logEl.textContent += s + "\\n"; console.log.apply(console, arguments); }

function escapeHtml(s){ return s.replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;','\\'':'&#39;'}[c])); }

async function sha256Hex(str){
  const enc = new TextEncoder().encode(str);
  const buf = await crypto.subtle.digest('SHA-256', enc);
  return [...new Uint8Array(buf)].map(b => b.toString(16).padStart(2,'0')).join('');
}
function slugify(s){ return s.toLowerCase().replace(/[^a-z0-9\\s-]/g,'').trim().replace(/\\s+/g,'-').replace(/-+/g,'-').slice(0,120); }
function tokenize(s){ return Array.from(new Set((s.toLowerCase().match(/[a-z0-9]{2,}/g) || []).slice(0,1200))); }
function sanitizeMergeConflicts(t){ return t.replace(/^<{7}[\\s\\S]*?^={7}[\\s\\S]*?^>{7}.*$/gm,''); }

function extractLinks(md){
  const links = [];
  const re = /\\[([^\\]]+)\\]\\(([^)\\s]+)(?:\\s+\\"([^\\"]*)\\")?\\)/g; // [text](url "title")
  let m; while((m = re.exec(md))){ links.push({text:m[1], href:m[2]}); }
  return links;
}
function splitBlocks(md){
  // optional sanitize conflicts
  if ($$('#sanitize').checked) md = sanitizeMergeConflicts(md);

  // Preserve code fences by temporarily marking them
  const fences = [];
  const fenced = md.replace(/```([\\s\\S]*?)```/g, (m, p1) => { const key = `__FENCE_${fences.length}__`; fences.push(m); return key; });
  const lines = fenced.split(/\\r?\\n/);
  const blocks = [];
  let cur = [];
  const hrRe = /^\\s*(?:-{3,}|\\*{3,}|_{3,})\\s*$/;
  const hRe = /^#{1,3}\\s+.+/;
  for (let i=0;i<lines.length;i++){
    const L = lines[i];
    if (i>0 && (hRe.test(L) || hrRe.test(L))){ if (cur.length){ blocks.push(cur.join('\\n')); cur = []; } }
    cur.push(L);
  }
  if (cur.length) blocks.push(cur.join('\\n'));
  // Restore code fences
  const restored = blocks.map(b => b.replace(/__FENCE_(\\d+)__/g, (_,i)=>fences[+i]));
  return restored.map(b => b.trim()).filter(Boolean);
}
function extractTitle(block, fallback){
  const m = block.match(/^#{1,6}\\s+(.+)/);
  if (m) return m[1].trim();
  const b = block.split(/\\n/)[0].trim();
  return b.length>0? (b.length>120? b.slice(0,120)+'…' : b) : fallback;
}
function excerpt(s){
  const plain = s.replace(/```[\\s\\S]*?```/g,' ')
                 .replace(/\\!\\[[^\\]]*\\]\\([^\\)]*\\)/g,' ')
                 .replace(/\\[[^\\]]*\\]\\([^\\)]*\\)/g,' ')
                 .replace(/[#>*_`~\\-]/g,' ');
  return plain.replace(/\\s+/g,' ').trim().slice(0,220);
}
function uniqueByIdSlug(arr){
  const seen = new Set(), out=[];
  for(const it of arr){ const k = (it && typeof it==='object') ? `${it.id||''}::${it.slug||''}` : JSON.stringify(it); if (seen.has(k)) continue; seen.add(k); out.push(it); }
  return out;
}

// ------------- Ingestor state -------------
let mdFiles = []; // [{name, text}]
const ingStatus = $$('#ingStatus');
const fileCountEl = $$('#fileCount');
const blockCountEl = $$('#blockCount');
const fileList = $$('#fileList');
const preview = $$('#preview');
const btnGenerate = $$('#btnGenerate');
const btnLoadViewer = $$('#btnLoadViewer');
const zipLink = $$('#zipLink');
const genMeta = $$('#genMeta');

function setIngStatus(text, type){ ingStatus.textContent = text; ingStatus.className = 'badge ' + (type||'muted'); }

function resetIngestor(){
  mdFiles = [];
  fileList.innerHTML = '';
  fileCountEl.textContent = '0';
  blockCountEl.textContent = '0';
  btnGenerate.disabled = true;
  btnLoadViewer.disabled = true;
  zipLink.style.display = 'none';
  preview.textContent = '';
  genMeta.textContent = '';
  setIngStatus('Idle','muted');
}
resetIngestor();
$('#btnClear')

// ------------- Drag/drop & browse -------------
const drop = $$('#drop');
const fileInput = $$('#file');
drop.addEventListener('dragover', e => { e.preventDefault(); drop.classList.add('drag'); });
drop.addEventListener('dragleave', e => { drop.classList.remove('drag'); });
drop.addEventListener('drop', async e => { e.preventDefault(); drop.classList.remove('drag'); await handleFiles(e.dataTransfer.files); });
drop.addEventListener('click', () => fileInput.click());
fileInput.addEventListener('change', async e => { await handleFiles(e.target.files); });

async function handleFiles(list){
  const arr = [...list].filter(f => /\\.(md|markdown|txt)$/i.test(f.name));
  for (const f of arr){
    let text = await f.text();
    if ($$('#sanitize').checked) text = sanitizeMergeConflicts(text);
    mdFiles.push({name:f.name, text});
    const size = new Intl.NumberFormat().format(f.size);
    const el = document.createElement('div');
    el.className = 'item';
    el.innerHTML = `<span class="pill">MD</span> <b>${escapeHtml(f.name)}</b> <span class="small muted">${size} bytes</span>`;
    fileList.appendChild(el);
  }
  fileCountEl.textContent = String(mdFiles.length);
  btnGenerate.disabled = mdFiles.length === 0;
  setIngStatus('Ready','ok');
}

// ------------- Generate JSONs -------------
async function readJson(fileInput){
  const f = fileInput.files && fileInput.files[0];
  if (!f) return null; try{ return JSON.parse(await f.text()); }catch(e){ console.warn('Invalid JSON', e); return null; }
}
let generated = null; // {registryDoc, searchDoc, crossDoc}

async function generate(){
  try{
    setIngStatus('Generating…','muted');
    zipLink.style.display = 'none';
    preview.textContent = '';

    const collection = $$('#collection').value.trim() || 'kb';
    const baseUrl = $$('#baseUrl').value.trim();

    const existingRegistry = await readJson($$('#existingRegistry'));
    const existingSearch = await readJson($$('#existingSearch'));
    const existingCross = await readJson($$('#existingCross'));

    const registryItems = [];
    const searchItems = [];
    const edges = [];
    let totalBlocks = 0;

    for (const file of mdFiles){
      const blocks = splitBlocks(file.text);
      for (let i=0;i<blocks.length;i++){
        const block = blocks[i];
        const title = extractTitle(block, file.name.replace(/\\.(md|markdown|txt)$/i,''));
        const id = await sha256Hex(file.name+'|'+i+'|'+title+'|'+block);
        const slug = slugify(title || (file.name+ '-' + i));
        const wc = (block.match(/\\S+/g) || []).length;
        const headings = (block.match(/^#{1,6}\\s+.+/gm) || []).map(s=>s.replace(/^#+\\s+/,'').trim());
        const links = extractLinks(block);
        const now = new Date().toISOString();
        const hash = await sha256Hex(block);

        const source_url = baseUrl ? (baseUrl.replace(/\\/$/,'') + '/' + encodeURIComponent(file.name)) : null;

        registryItems.push({ id, title, slug, collection, file:file.name, block_index:i, word_count:wc, headings, links, hash, updated_at: now, source_url });

        searchItems.push({ id, title, excerpt: excerpt(block), tokens: tokenize(block) });

        for (const l of links){ edges.push({ source:id, target:l.href, label:l.text || null }); }
      }
      totalBlocks += blocks.length;
    }
    blockCountEl.textContent = String(totalBlocks);

    const doDedupe = $$('#dedupe').checked;
    function maybeUnique(arr){ return doDedupe ? uniqueByIdSlug(arr) : arr; }

    const registryDoc = {
      version: 1,
      generated_at: new Date().toISOString(),
      items: maybeUnique([...(existingRegistry?.items||existingRegistry||[]), ...registryItems])
    };
    const searchDoc = maybeUnique([...(existingSearch||[]), ...searchItems]);
    const crossDoc = {
      version: 1,
      generated_at: new Date().toISOString(),
      edges: maybeUnique([...(existingCross?.edges||existingCross||[]), ...edges])
    };

    generated = {registryDoc, searchDoc, crossDoc};
    const prev = [registryDoc.items[0], registryDoc.items[1]].filter(Boolean);
    preview.textContent = JSON.stringify(prev, null, 2);
    genMeta.textContent = `Created ${registryDoc.items.length} registry items, ${searchDoc.length} search entries, ${crossDoc.edges.length} cross-links.`;
    setIngStatus('Generated','ok');
    btnLoadViewer.disabled = false;

    // Prepare ZIP
    const zip = new JSZip();
    zip.file('registry.json', JSON.stringify(registryDoc, null, 2));
    zip.file('search.json', JSON.stringify(searchDoc, null, 2));
    zip.file('cross_links.json', JSON.stringify(crossDoc, null, 2));
    const blob = await zip.generateAsync({type:'blob'});
    const href = URL.createObjectURL(blob);
    zipLink.href = href; zipLink.style.display = 'inline-block';
  }catch(e){
    setIngStatus('Error','err');
    alert('Generation failed: ' + e.message);
    console.error(e);
  }
}
btnGenerate.addEventListener('click', generate);

// ------------- Load into Viewer (without uploading) -------------
function normSearch(j){ if (Array.isArray(j)) return j; if (j && typeof j==='object') return j.items||j.docs||j.search||j.results||j.index||[]; return []; }
function normReg(j){ if (Array.isArray(j)) return j; if (j && typeof j==='object') return j.registry||j.items||j.docs||[]; return []; }
function normX(j){ if (Array.isArray(j)) return {edges:j}; if (j && typeof j==='object'){ if (Array.isArray(j.edges)) return {edges:j.edges}; if (j.graph && Array.isArray(j.graph.edges)) return {edges:j.graph.edges}; if (Array.isArray(j.links)) return {edges:j.links}; if (Array.isArray(j.relations)) return {edges:j.relations}; } return {edges:[]}; }

function applyViewerState(reg, s, x){
  const REG = normReg(reg).slice();
  const SEA = normSearch(s).slice();
  const XL  = normX(x).edges.slice();

  // Update UI counts & previews
  function setBadge(el, ok){ el.textContent = ok ? 'OK' : 'ERR'; el.className = 'badge ' + (ok?'ok':'err'); }
  setBadge(document.getElementById('regStatus'), true);
  setBadge(document.getElementById('sStatus'), true);
  setBadge(document.getElementById('xStatus'), true);

  document.getElementById('regCount').textContent = REG.length + ' items (local)';
  document.getElementById('sCount').textContent   = SEA.length + ' docs (local)';
  document.getElementById('xCount').textContent   = XL.length  + ' edges (local)';

  document.getElementById('regPreview').textContent = JSON.stringify(REG.slice(0,3),null,2);
  document.getElementById('sPreview').textContent   = JSON.stringify(SEA.slice(0,3),null,2);
  document.getElementById('xPreview').textContent   = JSON.stringify(XL.slice(0,3),null,2);

  document.getElementById('resolved').textContent = JSON.stringify({ registry:'(local)', search:'(local)', cross_links:'(local)' }, null, 2);
  document.getElementById('status').innerHTML = '<span class="badge ok">Loaded (local docs)</span>';

  // Stash globally to allow "Download current JSONs"
  window.__KB = { reg:{json:reg,url:'(local)'}, s:{json:s,url:'(local)'}, x:{json:x,url:'(local)'}, REG, SEA, XL };
}

btnLoadViewer.addEventListener('click', () => {
  if (!generated){ alert('Nothing generated yet'); return; }
  applyViewerState(generated.registryDoc, generated.searchDoc, generated.crossDoc);
});

// ------------- Probe (fetch remote JSONs) -------------
const qs = new URLSearchParams(location.search);
const baseInput = document.getElementById('base');
const rawInput  = document.getElementById('rawBase');
baseInput.value = qs.get('base') || localStorage.getItem('kb.base') || baseInput.value;
rawInput.value  = qs.get('rawBase') || localStorage.getItem('kb.rawBase') || rawInput.value;
document.getElementById('apply').onclick = () => {
  localStorage.setItem('kb.base', baseInput.value);
  localStorage.setItem('kb.rawBase', rawInput.value);
  location.search = `?base=${encodeURIComponent(baseInput.value)}&rawBase=${encodeURIComponent(rawInput.value)}`;
};
document.getElementById('clearCache').onclick = () => { caches && caches.keys && caches.keys().then(keys=>keys.forEach(k=>caches.delete(k))); localStorage.clear(); alert('Cache cleared. Reloading.'); location.reload(); };
document.getElementById('probe').onclick = probe;
window.addEventListener('load', ()=>{ probe(); });

function candidates(base, raw, file){
  const list = [];
  if (base) list.push(`${base.replace(/\\/$/,'')}/${file}`);
  list.push(`/${file}`);
  if (raw) list.push(`${raw.replace(/\\/$/,'')}/${file}`);
  return list;
}
async function fetchOne(url){ const t0=performance.now(); const res = await fetch(url,{cache:'no-store'}); const txt = await res.text(); if(!res.ok) throw new Error(`HTTP ${res.status}: ${txt.slice(0,120)}`); let j; try{ j = JSON.parse(txt); }catch(e){ throw new Error(`Parse error: ${e.message}. First 200: ${txt.slice(0,200)}`); } return { j, ms:(performance.now()-t0).toFixed(1) }; }
async function getJson(name, file, base, raw){
  const urls = candidates(base, raw, file);
  let lastErr = null;
  for(const u of urls){
    try{ log('Trying', name, '→', u); const {j, ms} = await fetchOne(u); log('OK', name, '@', u, `${ms}ms`); return { url:u, json:j }; }
    catch(e){ lastErr = e; log('FAIL', name, '@', u, String(e)); }
  }
  throw new Error(`Could not load ${name}: ${lastErr}`);
}
async function probe(){
  const base = baseInput.value.trim();
  const raw  = rawInput.value.trim();
  logEl.textContent='';
  document.getElementById('status').textContent='Probing…';

  let reg, s, x;
  try{ reg = await getJson('registry.json','registry.json',base,raw); }catch(e){}
  try{ s   = await getJson('search.json','search.json',base,raw); }catch(e){}
  try{ x   = await getJson('cross_links.json','cross_links.json',base,raw); }catch(e){}

  const REG = reg ? normReg(reg.json) : [];
  const SEA = s   ? normSearch(s.json) : [];
  const XL  = x   ? normX(x.json).edges : [];

  function setBadge(el, ok){ el.textContent = ok ? 'OK' : 'ERR'; el.className = 'badge ' + (ok?'ok':'err'); }
  setBadge(document.getElementById('regStatus'), !!reg);
  setBadge(document.getElementById('sStatus'),   !!s);
  setBadge(document.getElementById('xStatus'),   !!x);

  document.getElementById('regCount').textContent = REG.length + ' items';
  document.getElementById('sCount').textContent   = SEA.length + ' docs';
  document.getElementById('xCount').textContent   = XL.length  + ' edges';

  document.getElementById('regPreview').textContent = reg ? JSON.stringify(REG.slice(0,3),null,2) : '';
  document.getElementById('sPreview').textContent   = s   ? JSON.stringify(SEA.slice(0,3),null,2) : '';
  document.getElementById('xPreview').textContent   = x   ? JSON.stringify(XL.slice(0,3),null,2) : '';

  document.getElementById('resolved').textContent = JSON.stringify({
    registry: reg && reg.url, search: s && s.url, cross_links: x && x.url
  }, null, 2);

  const allOk = !!(reg && s && x);
  document.getElementById('status').innerHTML = allOk ? '<span class="badge ok">Healthy</span>' : '<span class="badge err">Issues detected</span>';

  window.__KB = { reg, s, x, REG, SEA, XL };
}

// ------------- Download current JSONs -------------
document.getElementById('downloadAll').onclick = async () => {
  try{
    if(!window.__KB) throw new Error('Nothing loaded yet');
    const zip = new JSZip();
    const {reg, s, x} = window.__KB;
    if(reg) zip.file('registry.json', JSON.stringify(reg.json, null, 2));
    if(s)   zip.file('search.json',   JSON.stringify(s.json,   null, 2)); // keep pretty
    if(x)   zip.file('cross_links.json', JSON.stringify(x.json, null, 2));
    const blob = await zip.generateAsync({type:'blob'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'kb_payload.zip';
    a.click();
  }catch(e){ alert('Download failed: ' + e.message); }
};
</script>
</body>
</html>
