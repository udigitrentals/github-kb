<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>KB Live Viewer + Uploader</title>
  <style>
    :root {
      --brand-text: #E1BC56;
      --brand-cta: #A90F0F;
      --bg: #0b0b0b;
      --panel: #111;
      --ink: #e8e8e8;
      --muted: #a5a5a5;
      --ok: #1f9d55;
      --warn: #d39e00;
      --err: #c0392b;
      --radius: 12px;
    }
    * { box-sizing: border-box; }
    body { margin: 0; padding: 24px; background: var(--bg); color: var(--ink);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans"; }
    h1 { margin: 0 0 10px; }
    .sub { color: var(--muted); margin: 0 0 20px; }
    .row { display: flex; gap: 16px; flex-wrap: wrap; align-items: center; }
    button, .btn { background: var(--brand-cta); color: #fff; border: none; border-radius: var(--radius);
      padding: 10px 14px; cursor: pointer; font-weight: 600; }
    button.secondary { background: #333; color: var(--ink); }
    button:disabled { opacity: .5; cursor: not-allowed; }
    .pill { border: 1px solid #333; border-radius: 999px; padding: 6px 10px; color: var(--muted); }
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px; margin-top: 16px; }
    .card { background: var(--panel); border-radius: var(--radius); padding: 16px; }
    .card h3 { margin-top: 0; }
    pre { background: #000; color: #e6e6e6; padding: 12px; border-radius: var(--radius);
      overflow:auto; max-height: 50vh; border: 1px solid #222; }
    a { color: var(--brand-text); text-decoration: none; }
    .drop { border: 2px dashed #333; border-radius: var(--radius); padding: 18px; text-align: center; color: var(--muted); }
    .drop.drag { border-color: var(--brand-text); color: var(--brand-text); }
    details { border: 1px solid #222; border-radius: var(--radius); padding: 10px 12px; background: #0d0d0d; }
    details > summary { cursor: pointer; font-weight: 600; }
    .status.ok { color: var(--ok); }
    .status.err { color: var(--err); }
    .status.warn { color: var(--warn); }
    footer { margin-top: 36px; color: var(--muted); font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>
<body>
  <h1>KB Live Viewer</h1>
  <p class="sub">Loads <span class="mono">/docs/registry.json</span>, <span class="mono">/docs/cross_links.json</span>, and <span class="mono">/docs/search.json</span>. Upload Markdown to append entries and download updated JSONs for commit.</p>

  <div class="row">
    <button id="reloadBtn">Reload</button>
    <span id="basePath" class="pill">Base: <span class="mono">/docs</span></span>
    <span id="counts" class="pill">—</span>
  </div>

  <div class="grid" style="margin-top:18px">
    <div class="card">
      <h3>Upload Markdown</h3>
      <div id="drop" class="drop">Drag & drop .md here or use picker below</div>
      <div class="row" style="margin-top:10px">
        <input id="fileInput" type="file" accept=".md,text/markdown" multiple />
        <button id="downloadRegistry" class="secondary" disabled>Download updated registry.json</button>
        <button id="downloadSearch" class="secondary" disabled>Download updated search.json</button>
        <button id="downloadCross" class="secondary" disabled>Download updated cross_links.json</button>
      </div>
      <p id="uploadStatus" class="sub"></p>
    </div>

    <div class="card">
  <h3>Diagnostics</h3>
  <div class="row">
    <button id="btnHealth" class="secondary">Run Health Check</button>
    <button id="btnDlStats" class="secondary">Download kb_stats.json</button>
  </div>
  <pre id="health">Click “Run Health Check”</pre>
</div>


    <div class="card">
      <h3>Debug / Direct Links</h3>
      <ul>
        <li><a id="linkReg" href="/docs/registry.json" target="_blank">/docs/registry.json</a></li>
        <li><a id="linkX"  href="/docs/cross_links.json" target="_blank">/docs/cross_links.json</a></li>
        <li><a id="linkS"  href="/docs/search.json" target="_blank">/docs/search.json</a></li>
      </ul>
      <details style="margin-top:8px"><summary>Loader status</summary>
        <pre id="log">Waiting…</pre>
      </details>
    </div>

    <div class="card">
      <h3>Validate & Commit</h3>
      <div class="row">
        <input id="commitMsg" placeholder="Commit message" style="padding:6px; flex: 1 1 280px">
        <input id="kbKey" type="password" placeholder="Key (KB_PROTECT_KEY)" style="padding:6px; flex: 1 1 280px">
      </div>
      <div class="row" style="margin-top:8px">
        <button id="btnValidate" class="secondary">Validate (schemas)</button>
        <button id="btnCommit">Validate & Commit to GitHub</button>
      </div>
      <pre id="apiLog" style="background:#0f0f0f; padding:8px; max-height:220px; overflow:auto"></pre>
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <h3>registry.json</h3>
      <pre id="reg">Loading…</pre>
    </div>
    <div class="card">
      <h3>cross_links.json</h3>
      <pre id="xln">Loading…</pre>
    </div>
    <div class="card">
      <h3>search.json</h3>
      <pre id="srch">Loading…</pre>
    </div>
  </div>

  <footer>Tip: If you previously had a service worker, add <span class="mono">?nosw=1</span> to the URL once to bypass it.</footer>

<script>
/* ------------------------------
   Small utilities
--------------------------------*/

async function runHealth() {
  const r = await fetch('/api/kb/health', { cache: 'no-store' });
  const j = await r.json();
  document.getElementById('health').textContent = JSON.stringify(j, null, 2);
  beacon('health_checked', { ok: j.ok, elapsed_ms: j.elapsed_ms });
}
document.getElementById('btnHealth').addEventListener('click', runHealth);

document.getElementById('btnDlStats').addEventListener('click', async () => {
  try {
    const r = await fetch(`${BASE}/kb_stats.json`, { cache: 'no-store' });
    if (!r.ok) throw new Error('not found');
    const j = await r.json();
    downloadJSON(j, 'kb_stats.json');
  } catch {
    alert('Stats not found yet. Commit once or run health first.');
  }
});

const sleep = (ms) => new Promise(r => setTimeout(r, ms));
const ts = () => Date.now();
const uuid = () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
  const r = crypto.getRandomValues(new Uint8Array(1))[0] & 15;
  const v = c === 'x' ? r : (r & 0x3 | 0x8);
  return v.toString(16);
});
const slugify = (s) => s.toLowerCase()
  .replace(/[`~!@#$%^&*()+=\[\]{}|\\'";:,.<>/?]/g,'')
  .replace(/\s+/g,'-').replace(/-+/g,'-').replace(/^-|-$/g,'');

function extractTitle(md, fallback) {
  const m = md.match(/^\s*#\s+(.+?)\s*$/m);
  if (m && m[1]) return m[1].trim();
  const m2 = md.match(/^\s*(.+)\n=+\s*$/m);
  if (m2 && m2[1]) return m2[1].trim();
  return fallback.replace(/\.[^/.]+$/, '');
}

function downloadJSON(obj, filename) {
  const blob = new Blob([JSON.stringify(obj, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = filename; a.click();
  setTimeout(() => URL.revokeObjectURL(url), 1000);
}

/* ------------------------------
   Canonical loader (/docs first)
--------------------------------*/
let BASE = '/docs';
let registryRaw = null, registryArr = [];
let searchRaw = null, searchArr = [];
let crossRaw = null, crossObj = { nodes: [], edges: [] }, crossMap = null, crossKind = 'graph';

const els = {
  reg: document.getElementById('reg'),
  xln: document.getElementById('xln'),
  srch: document.getElementById('srch'),
  log: document.getElementById('log'),
  counts: document.getElementById('counts'),
  basePath: document.getElementById('basePath'),
  downloadRegistry: document.getElementById('downloadRegistry'),
  downloadSearch: document.getElementById('downloadSearch'),
  downloadCross: document.getElementById('downloadCross'),
  uploadStatus: document.getElementById('uploadStatus'),
  apiLog: document.getElementById('apiLog'),
};

async function fetchJSON(path) {
  const url = `${path}?ts=${ts()}${location.search.includes('nosw=1') ? '&nosw=1' : ''}`;
  const res = await fetch(url, { cache: 'no-store' });
  if (!res.ok) throw new Error(`HTTP ${res.status} for ${path}`);
  return res.json();
}

async function tryLoadFrom(base) {
  try {
    const [r, x, s] = await Promise.all([
      fetchJSON(`${base}/registry.json`),
      fetchJSON(`${base}/cross_links.json`),
      fetchJSON(`${base}/search.json`),
    ]);
    return { ok: true, base, r, x, s };
  } catch (e) {
    return { ok: false, base, err: String(e) };
  }
}

function normalizeRegistry(raw) {
  let arr = [];
  if (Array.isArray(raw)) arr = raw;
  else if (raw && Array.isArray(raw.items)) arr = raw.items;
  else if (raw && Array.isArray(raw.registry)) arr = raw.registry;
  else return [];
  const flat = []; const stack = [arr];
  while (stack.length) {
    const cur = stack.pop();
    for (const v of cur) Array.isArray(v) ? stack.push(v) : flat.push(v);
  }
  return flat;
}

function denormalizeRegistry(arr, template) {
  if (template && !Array.isArray(template) && Array.isArray(template.items)) return { ...template, items: arr };
  if (template && !Array.isArray(template) && Array.isArray(template.registry)) return { ...template, registry: arr };
  return arr;
}

function normalizeSearch(raw) {
  let arr = [];
  if (Array.isArray(raw)) arr = raw;
  else if (raw && Array.isArray(raw.docs)) arr = raw.docs;
  else if (raw && Array.isArray(raw.items)) arr = raw.items;
  else return [];
  const flat = []; const stack = [arr];
  while (stack.length) {
    const cur = stack.pop();
    for (const v of cur) Array.isArray(v) ? stack.push(v) : flat.push(v);
  }
  return flat;
}

function denormalizeSearch(arr, template) {
  if (template && !Array.isArray(template) && Array.isArray(template.docs)) return { ...template, docs: arr };
  if (template && !Array.isArray(template) && Array.isArray(template.items)) return { ...template, items: arr };
  return arr;
}

function normalizeCross(raw) {
  if (!raw) return { kind:'graph', nodes:[], edges:[], map:null, template: raw };
  const isMap = !Array.isArray(raw) && !Array.isArray(raw.nodes) && !raw.graph &&
                typeof raw === 'object' && Object.keys(raw).length > 0 &&
                Object.values(raw).every(v => v && typeof v === 'object' && Array.isArray(v.neighbors));
  if (isMap) return { kind:'map', nodes:[], edges:[], map:raw, template: raw };

  let nodes = [], edges = [];
  if (Array.isArray(raw.nodes)) nodes = raw.nodes;
  if (Array.isArray(raw.edges)) edges = raw.edges;
  if (raw.graph) {
    if (Array.isArray(raw.graph.nodes)) nodes = raw.graph.nodes;
    if (Array.isArray(raw.graph.edges)) edges = raw.graph.edges;
  }
  return { kind:'graph', nodes, edges, map:null, template: raw };
}

function denormalizeCross(obj) {
  const t = crossRaw;
  const isMap = t && typeof t === 'object' && !Array.isArray(t) && !t.graph &&
                Object.values(t).every(v => v && typeof v === 'object' && Array.isArray(v.neighbors));
  if (isMap) {
    const out = { ...t };
    const src = crossMap || {};
    for (const [path, entry] of Object.entries(src)) {
      if (!out[path]) out[path] = { neighbors: [] };
      const set = new Set(out[path].neighbors || []);
      for (const n of (entry.neighbors || [])) set.add(n);
      out[path].neighbors = Array.from(set);
    }
    return out;
  }
  if (t && t.graph && Array.isArray(t.graph.nodes) && Array.isArray(t.graph.edges)) {
    return { ...t, graph: { ...t.graph, nodes: obj.nodes, edges: obj.edges } };
  }
  if (t && Array.isArray(t.nodes) && Array.isArray(t.edges)) {
    return { ...t, nodes: obj.nodes, edges: obj.edges };
  }
  return obj;
}

function setCounts() {
  const r = registryArr?.length ?? 0;
  const s = searchArr?.length ?? 0;
  const n = (crossKind === 'map') ? Object.keys(crossMap || {}).length : (crossObj?.nodes || []).length;
  els.counts.textContent = `registry: ${r} • search: ${s} • nodes: ${n}`;
}

function buildMerged() {
  const mergedRegistry = denormalizeRegistry(registryArr, registryRaw);
  const mergedSearch   = denormalizeSearch(searchArr,  searchRaw);
  const mergedCross    = (crossKind === 'map') ? (crossMap || {}) : denormalizeCross(crossObj);
  return { registry: mergedRegistry, search: mergedSearch, cross: mergedCross };
}

async function loadAll() {
  els.log.textContent = 'Loading…';
  let attempt = await tryLoadFrom('/docs');
  if (!attempt.ok) attempt = await tryLoadFrom('/kb');
  if (!attempt.ok) attempt = await tryLoadFrom('/ml/kb');

  if (!attempt.ok) {
    els.log.textContent = `Failed to load from /docs, /kb, or /ml/kb.\n${attempt.err}`;
    return;
  }
  BASE = attempt.base;
  els.basePath.innerHTML = 'Base: <span class="mono">' + BASE + '</span>';
  document.getElementById('linkReg').href = `${BASE}/registry.json`;
  document.getElementById('linkX').href   = `${BASE}/cross_links.json`;
  document.getElementById('linkS').href   = `${BASE}/search.json`;

  registryRaw = attempt.r; registryArr = normalizeRegistry(registryRaw);
  searchRaw   = attempt.s; searchArr   = normalizeSearch(searchRaw);
  crossRaw    = attempt.x;
  const crossParsed = normalizeCross(crossRaw);
  crossKind = crossParsed.kind;
  if (crossKind === 'map') { crossMap = JSON.parse(JSON.stringify(crossParsed.map || {})); crossObj = { nodes: [], edges: [] }; }
  else { crossObj = { nodes: crossParsed.nodes, edges: crossParsed.edges }; crossMap = null; }

  els.reg.textContent  = JSON.stringify(registryRaw, null, 2);
  els.srch.textContent = JSON.stringify(searchRaw, null, 2);
  els.xln.textContent  = JSON.stringify(crossRaw, null, 2);

  setCounts();
  [els.downloadRegistry, els.downloadSearch, els.downloadCross].forEach(b => b.disabled = false);
}

/* ------------------------------
   Upload & append (lossless)
--------------------------------*/
function tokenizeForSearch(md) {
  return md.toLowerCase().replace(/[`*_>#\-]/g,' ')
    .replace(/[^\w\s]/g,' ').replace(/\s+/g,' ').trim();
}

async function handleFiles(fileList) {
  const files = Array.from(fileList).filter(f => /\.md$/i.test(f.name));
  if (!files.length) { els.uploadStatus.innerHTML = `<span class="status warn">No .md files detected.</span>`; return; }
  let added = 0;

  const slugTaken = new Set((registryArr || []).map(it => (it.slug || it.path || '').toString().toLowerCase()));

  for (const file of files) {
    const text = await file.text();
    const title = extractTitle(text, file.name);
    const baseSlug = slugify(title || file.name);
    let slug = baseSlug;
    let inc = 2;
    while (slugTaken.has(`/docs/md/${slug}.md`) || slugTaken.has(slug) || registryArr.some(it => (it.slug || it.title || '').toLowerCase() === slug)) {
      slug = `${baseSlug}-${inc++}`;
    }

    const id = uuid();
    const when = new Date().toISOString();

    // Append to registry (append-only)
    const regItem = { id, title, slug, path: `/docs/md/${slug}.md`, tags: [], created_at: when };
    registryArr.push(regItem); slugTaken.add(slug);

    // Append to search
    const searchItem = { id, title, content: text, tokens: tokenizeForSearch(text), created_at: when };
    searchArr.push(searchItem);

    // Append to cross links (simple extraction)
    const links = Array.from(text.matchAll(/\[.+?\]\(([^)]+)\)|\[\[([^\]]+)\]\]/g));
    const neighborPaths = [];
    for (const m of links) {
      const rawTarget = (m[1] || m[2] || '').trim().toLowerCase();
      if (!rawTarget) continue;
      const target = registryArr.find(it =>
        (it.slug && rawTarget.includes(it.slug.toLowerCase())) ||
        (it.title && rawTarget.includes(it.title.toLowerCase())) ||
        (it.path && rawTarget.includes((it.path || '').toLowerCase()))
      );
      if (target?.path) neighborPaths.push(target.path);
    }
    if (crossKind === 'map') {
      if (!crossMap) crossMap = {};
      if (!crossMap[regItem.path]) crossMap[regItem.path] = { neighbors: [] };
      const set = new Set(crossMap[regItem.path].neighbors || []);
      for (const p of neighborPaths) set.add(p);
      crossMap[regItem.path].neighbors = Array.from(set);
    } else {
      const node = { id, title, slug, path: regItem.path };
      crossObj.nodes.push(node);
      for (const p of neighborPaths) {
        const targetNode = crossObj.nodes.find(n => n.path === p) ||
                           (registryArr.find(it => it.path === p) ? { id: 'unknown', path: p } : null);
        if (targetNode) crossObj.edges.push({ source: id, target: targetNode.id || 'unknown', type: 'ref' });
      }
    }
    added++;
  }

  els.uploadStatus.innerHTML = `<span class="status ok">${added}</span> Markdown file(s) appended. Download JSONs or use Validate & Commit.`;
  setCounts();

  // refresh preview panes
  els.reg.textContent  = JSON.stringify(denormalizeRegistry(registryArr, registryRaw), null, 2);
  els.srch.textContent = JSON.stringify(denormalizeSearch(searchArr,  searchRaw), null, 2);
  const crossOut = (crossKind === 'map') ? (crossMap || {}) : denormalizeCross(crossObj);
  els.xln.textContent  = JSON.stringify(crossOut, null, 2);
}

/* ------------------------------
   Validate & Commit buttons
--------------------------------*/
async function validateMerged() {
  const merged = buildMerged();
  const r = await fetch('/api/kb/validate', {
    method: 'POST', headers: { 'content-type': 'application/json' },
    body: JSON.stringify(merged)
  });
  const j = await r.json();
  els.apiLog.textContent = JSON.stringify(j, null, 2);
  alert(j.ok ? 'Validation OK (see log for warnings)' : 'Schema validation failed — see log');
}

async function commitMerged() {
  const merged = buildMerged();
  merged.message = document.getElementById('commitMsg').value || 'KB: ingest';
  const key = document.getElementById('kbKey').value || '';
  const r = await fetch('/api/kb/commit', {
    method: 'POST',
    headers: { 'content-type': 'application/json', 'x-kb-key': key },
    body: JSON.stringify(merged)
  });
  const j = await r.json();
  els.apiLog.textContent = JSON.stringify(j, null, 2);
  alert(r.ok ? 'Committed to GitHub ✔' : 'Commit failed — see log');
}

/* ------------------------------
   Wire UI + boot
--------------------------------*/
document.getElementById('reloadBtn').addEventListener('click', loadAll);
document.getElementById('btnValidate').addEventListener('click', validateMerged);
document.getElementById('btnCommit').addEventListener('click', commitMerged);

// Drag & drop
const dropEl = document.getElementById('drop');
dropEl.addEventListener('dragover', (e) => { e.preventDefault(); dropEl.classList.add('drag'); });
dropEl.addEventListener('dragleave', () => dropEl.classList.remove('drag'));
dropEl.addEventListener('drop', (e) => { e.preventDefault(); dropEl.classList.remove('drag'); handleFiles(e.dataTransfer.files); });
document.getElementById('fileInput').addEventListener('change', (e) => handleFiles(e.target.files));

// Download updated JSONs
els.downloadRegistry.addEventListener('click', () => downloadJSON(denormalizeRegistry(registryArr, registryRaw), 'registry.json'));
els.downloadSearch  .addEventListener('click', () => downloadJSON(denormalizeSearch (searchArr,  searchRaw),  'search.json'));
els.downloadCross   .addEventListener('click', () => {
  const out = (crossKind === 'map') ? (crossMap || {}) : denormalizeCross(crossObj);
  downloadJSON(out, 'cross_links.json');
});

// Boot
loadAll().catch(err => {
  els.log.textContent = `Failed to load: ${err.message}\nCheck that /docs/*.json exist and Vercel rewrites are correct.`;
});

function beacon(type, extra = {}) {
  return fetch('/api/kb/telemetry', {
    method: 'POST',
    headers: {'content-type':'application/json'},
    body: JSON.stringify({ type, ...extra })
  }).catch(()=>{});
}

// fire on key actions
document.getElementById('btnValidate').addEventListener('click', () => beacon('validate_click'));
document.getElementById('btnCommit').addEventListener('click', () => beacon('commit_click'));
document.getElementById('fileInput').addEventListener('change', (e) => beacon('upload_files', { files: e.target.files?.length || 0 }));

</script>
</body>
</html>
