<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>KB Live Viewer + Uploader</title>
  <style>
    :root {
      --brand-text: #E1BC56;
      --brand-cta: #A90F0F;
      --bg: #0b0b0b;
      --panel: #111;
      --ink: #e8e8e8;
      --muted: #a5a5a5;
      --ok: #1f9d55;
      --warn: #d39e00;
      --err: #c0392b;
      --radius: 12px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; padding: 24px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans";
      background: var(--bg); color: var(--ink);
    }
    h1 { margin: 0 0 10px; }
    .sub { color: var(--muted); margin: 0 0 20px; }
    .row { display: flex; gap: 16px; flex-wrap: wrap; align-items: center; }
    button, .btn {
      background: var(--brand-cta); color: #fff; border: none; border-radius: var(--radius);
      padding: 10px 14px; cursor: pointer; font-weight: 600;
    }
    button.secondary { background: #333; color: var(--ink); }
    button:disabled { opacity: .5; cursor: not-allowed; }
    .pill { border: 1px solid #333; border-radius: 999px; padding: 6px 10px; color: var(--muted); }
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px; margin-top: 16px; }
    .card { background: var(--panel); border-radius: var(--radius); padding: 16px; }
    .card h3 { margin-top: 0; }
    pre {
      background: #000; color: #e6e6e6; padding: 12px; border-radius: var(--radius);
      overflow:auto; max-height: 50vh; border: 1px solid #222;
    }
    a { color: var(--brand-text); text-decoration: none; }
    .drop {
      border: 2px dashed #333; border-radius: var(--radius); padding: 18px; text-align: center; color: var(--muted);
    }
    .drop.drag { border-color: var(--brand-text); color: var(--brand-text); }
    details { border: 1px solid #222; border-radius: var(--radius); padding: 10px 12px; background: #0d0d0d; }
    details > summary { cursor: pointer; font-weight: 600; }
    .status.ok { color: var(--ok); }
    .status.err { color: var(--err); }
    .status.warn { color: var(--warn); }
    footer { margin-top: 36px; color: var(--muted); font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>
<body>
  <h1>KB Live Viewer</h1>
  <p class="sub">Loads <span class="mono">/kb/registry.json</span>, <span class="mono">/kb/cross_links.json</span>, and <span class="mono">/kb/search.json</span>. Upload Markdown to append entries and download updated JSONs for commit.</p>

  <div class="row">
    <button id="reloadBtn">Reload from /kb</button>
    <span id="basePath" class="pill">Base: <span class="mono">/kb</span></span>
    <span id="counts" class="pill">—</span>
  </div>

  <div class="grid" style="margin-top:18px">
    <div class="card">
      <h3>Upload Markdown</h3>
      <div id="drop" class="drop">Drag & drop .md here or use picker below</div>
      <div class="row" style="margin-top:10px">
        <input id="fileInput" type="file" accept=".md,text/markdown" multiple />
        <button id="downloadRegistry" class="secondary" disabled>Download updated registry.json</button>
        <button id="downloadSearch" class="secondary" disabled>Download updated search.json</button>
        <button id="downloadCross" class="secondary" disabled>Download updated cross_links.json</button>
      </div>
      <p id="uploadStatus" class="sub"></p>
    </div>

    <div class="card">
      <h3>Debug / Direct Links</h3>
      <ul>
        <li><a id="linkReg" href="/kb/registry.json" target="_blank">/kb/registry.json</a></li>
        <li><a id="linkX" href="/kb/cross_links.json" target="_blank">/kb/cross_links.json</a></li>
        <li><a id="linkS" href="/kb/search.json" target="_blank">/kb/search.json</a></li>
      </ul>
      <details style="margin-top:8px"><summary>Loader status</summary>
        <pre id="log">Waiting…</pre>
      </details>
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <h3>registry.json</h3>
      <pre id="reg">Loading…</pre>
    </div>
    <div class="card">
      <h3>cross_links.json</h3>
      <pre id="xln">Loading…</pre>
    </div>
    <div class="card">
      <h3>search.json</h3>
      <pre id="srch">Loading…</pre>
    </div>
  </div>

  <footer>Tip: If you previously had a service worker, add <span class="mono">?nosw=1</span> to the URL once to bypass it.</footer>

<script>
/* ------------------------------
   Small utilities
--------------------------------*/
const sleep = (ms) => new Promise(r => setTimeout(r, ms));
const ts = () => Date.now();
const uuid = () => {
  // RFC4122-ish v4 without external deps
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
    const r = crypto.getRandomValues(new Uint8Array(1))[0] & 15;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
};
const slugify = (s) =>
  s.toLowerCase()
   .replace(/[`~!@#$%^&*()+=\[\]{}|\\'";:,.<>/?]/g,'')
   .replace(/\s+/g,'-')
   .replace(/-+/g,'-')
   .replace(/^-|-$/g,'');

function extractTitle(md, fallback) {
  // First H1
  const m = md.match(/^\s*#\s+(.+?)\s*$/m);
  if (m && m[1]) return m[1].trim();
  // Setext H1
  const m2 = md.match(/^\s*(.+)\n=+\s*$/m);
  if (m2 && m2[1]) return m2[1].trim();
  return fallback.replace(/\.[^/.]+$/, ''); // filename sans ext
}

function tokenizeForSearch(md) {
  // very naive tokenizer
  return md
    .toLowerCase()
    .replace(/[`*_>#\-]/g,' ')
    .replace(/[^\w\s]/g,' ')
    .replace(/\s+/g,' ')
    .trim();
}

function downloadJSON(obj, filename) {
  const blob = new Blob([JSON.stringify(obj, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename;
  document.body.appendChild(a); a.click();
  setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 1000);
}

/* ------------------------------
   KB Loader (with tolerant shapes)
--------------------------------*/
let BASE = '/kb'; // preferred
let registryRaw = null, registryArr = []; // normalized array
let searchRaw = null, searchArr = [];
let crossRaw = null, crossObj = { nodes: [], edges: [] };

const els = {
  reg: document.getElementById('reg'),
  xln: document.getElementById('xln'),
  srch: document.getElementById('srch'),
  log: document.getElementById('log'),
  counts: document.getElementById('counts'),
  basePath: document.getElementById('basePath'),
  downloadRegistry: document.getElementById('downloadRegistry'),
  downloadSearch: document.getElementById('downloadSearch'),
  downloadCross: document.getElementById('downloadCross'),
  uploadStatus: document.getElementById('uploadStatus'),
};

function setCounts() {
  const r = registryArr?.length ?? 0;
  const s = searchArr?.length ?? 0;
  const n = (crossObj?.nodes || []).length;
  els.counts.textContent = `registry: ${r} • search: ${s} • nodes: ${n}`;
}

async function fetchJSON(path) {
  const url = `${path}?ts=${ts()}${location.search.includes('nosw=1') ? '&nosw=1' : ''}`;
  const res = await fetch(url, { cache: 'no-store' });
  if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText} for ${path}`);
  return res.json();
}

async function tryLoadFrom(base) {
  const log = [];
  try {
    log.push(`Trying base ${base}`);
    const [r, x, s] = await Promise.all([
      fetchJSON(`${base}/registry.json`),
      fetchJSON(`${base}/cross_links.json`),
      fetchJSON(`${base}/search.json`),
    ]);
    log.push('Fetched all three JSONs ✅');
    return { ok: true, base, r, x, s, log: log.join('\n') };
  } catch (e) {
    return { ok: false, base, err: String(e), log: (log.join('\n') + '\n' + e.stack) };
  }
}

function normalizeRegistry(raw) {
  if (Array.isArray(raw)) return raw;
  if (raw && Array.isArray(raw.items)) return raw.items;
  if (raw && Array.isArray(raw.registry)) return raw.registry;
  return [];
}
function denormalizeRegistry(arr, template) {
  // Preserve original envelope if present; else return array
  if (template && !Array.isArray(template) && Array.isArray(template.items)) {
    return { ...template, items: arr };
  }
  if (template && !Array.isArray(template) && Array.isArray(template.registry)) {
    return { ...template, registry: arr };
  }
  return arr;
}

function normalizeSearch(raw) {
  if (Array.isArray(raw)) return raw;
  if (raw && Array.isArray(raw.docs)) return raw.docs;
  if (raw && Array.isArray(raw.items)) return raw.items;
  return [];
}
function denormalizeSearch(arr, template) {
  if (template && !Array.isArray(template) && Array.isArray(template.docs)) {
    return { ...template, docs: arr };
  }
  if (template && !Array.isArray(template) && Array.isArray(template.items)) {
    return { ...template, items: arr };
  }
  return arr;
}

function normalizeCross(raw) {
  let nodes = [], edges = [];
  if (raw && Array.isArray(raw.nodes)) nodes = raw.nodes;
  if (raw && Array.isArray(raw.edges)) edges = raw.edges;
  // Some people store as {graph:{nodes,edges}}
  if (raw && raw.graph) {
    if (Array.isArray(raw.graph.nodes)) nodes = raw.graph.nodes;
    if (Array.isArray(raw.graph.edges)) edges = raw.graph.edges;
  }
  return { nodes, edges, template: raw };
}
function denormalizeCross(obj) {
  const t = crossRaw;
  if (t && t.graph && Array.isArray(t.graph.nodes) && Array.isArray(t.graph.edges)) {
    return { ...t, graph: { ...t.graph, nodes: obj.nodes, edges: obj.edges } };
  }
  if (t && Array.isArray(t.nodes) && Array.isArray(t.edges)) {
    return { ...t, nodes: obj.nodes, edges: obj.edges };
  }
  return obj; // minimal {nodes,edges}
}

async function loadAll() {
  els.log.textContent = 'Loading…';
  // Try /kb first, then /ml/kb (in case rewrite missing)
  let attempt = await tryLoadFrom('/kb');
  if (!attempt.ok) {
    const err1 = attempt.err;
    attempt = await tryLoadFrom('/ml/kb');
    if (!attempt.ok) {
      els.log.textContent = `Both bases failed.\n\n/kb error:\n${err1}\n\n/ml/kb error:\n${attempt.err}\n\nEnsure your files are deployed under /kb/.`;
      throw new Error('Failed to load from /kb and /ml/kb');
    }
  }
  BASE = attempt.base;
  document.getElementById('basePath').innerHTML = 'Base: <span class="mono">' + BASE + '</span>';
  document.getElementById('linkReg').href = `${BASE}/registry.json`;
  document.getElementById('linkX').href = `${BASE}/cross_links.json`;
  document.getElementById('linkS').href = `${BASE}/search.json`;

  registryRaw = attempt.r;
  registryArr = normalizeRegistry(registryRaw);
  searchRaw = attempt.s;
  searchArr = normalizeSearch(searchRaw);
  crossRaw = attempt.x;
  crossObj = normalizeCross(crossRaw);

  els.reg.textContent = JSON.stringify(registryRaw, null, 2);
  els.srch.textContent = JSON.stringify(searchRaw, null, 2);
  els.xln.textContent = JSON.stringify(crossRaw, null, 2);
  els.log.textContent = attempt.log + `\n\nLoaded from ${BASE} ✅`;
  setCounts();

  // enable downloads
  [els.downloadRegistry, els.downloadSearch, els.downloadCross].forEach(b => b.disabled = false);
}

document.getElementById('reloadBtn').addEventListener('click', loadAll);

/* ------------------------------
   Upload and append logic
--------------------------------*/
async function handleFiles(fileList) {
  const files = Array.from(fileList).filter(f => /\.md$/i.test(f.name));
  if (!files.length) {
    els.uploadStatus.innerHTML = `<span class="status.warn">No .md files detected.</span>`;
    return;
  }
  let added = 0;
  for (const file of files) {
    const text = await file.text();
    const title = extractTitle(text, file.name);
    let baseSlug = slugify(title || file.name);
    let slug = baseSlug;
    // Ensure slug uniqueness within current registry
    const slugTaken = new Set((registryArr || []).map(it => (it.slug || it.path || '').toString().toLowerCase()));
    let inc = 2;
    while (slugTaken.has(`/kb/md/${slug}.md`) || slugTaken.has(slug) || registryArr.some(it => (it.slug || it.title || '').toLowerCase() === slug)) {
      slug = `${baseSlug}-${inc++}`;
    }
    const id = uuid();
    const when = new Date().toISOString();

    // Append to registry (append-only)
    const regItem = {
      id, title,
      slug,
      path: `/kb/md/${slug}.md`,
      tags: [],
      created_at: when
    };
    registryArr.push(regItem);

    // Append to search
    const searchItem = {
      id, title,
      content: text,
      tokens: tokenizeForSearch(text),
      created_at: when
    };
    searchArr.push(searchItem);

    // Append to cross links (node only; edges derive from links if any)
    const node = { id, title, slug, path: regItem.path };
    crossObj.nodes.push(node);

    // Naive markdown link edge extraction: [text](...slug...) or [[WikiLink]]
    const links = Array.from(text.matchAll(/\[.+?\]\(([^)]+)\)|\[\[([^\]]+)\]\]/g));
    for (const m of links) {
      const rawTarget = (m[1] || m[2] || '').trim().toLowerCase();
      if (!rawTarget) continue;
      // try to match by slug/title present in registry
      const target = registryArr.find(it =>
        (it.slug && rawTarget.includes(it.slug.toLowerCase())) ||
        (it.title && rawTarget.includes(it.title.toLowerCase()))
      );
      if (target) {
        crossObj.edges.push({ source: id, target: target.id, type: 'ref' });
      }
    }
    added++;
  }

  els.uploadStatus.innerHTML = `<span class="status.ok">${added}</span> Markdown file(s) appended. Don’t forget to <b>download</b> the updated JSONs and commit them under <span class="mono">${BASE}/</span>.`;
  setCounts();

  // Refresh the pretty JSON panes (show denormalized to preserve original envelopes)
  els.reg.textContent = JSON.stringify(denormalizeRegistry(registryArr, registryRaw), null, 2);
  els.srch.textContent = JSON.stringify(denormalizeSearch(searchArr, searchRaw), null, 2);
  els.xln.textContent = JSON.stringify(denormalizeCross(crossObj), null, 2);
}

// Drag & drop
const dropEl = document.getElementById('drop');
dropEl.addEventListener('dragover', (e) => { e.preventDefault(); dropEl.classList.add('drag'); });
dropEl.addEventListener('dragleave', () => dropEl.classList.remove('drag'));
dropEl.addEventListener('drop', (e) => {
  e.preventDefault(); dropEl.classList.remove('drag');
  handleFiles(e.dataTransfer.files);
});
document.getElementById('fileInput').addEventListener('change', (e) => handleFiles(e.target.files));

// Download updated JSONs
els.downloadRegistry.addEventListener('click', () => {
  downloadJSON(denormalizeRegistry(registryArr, registryRaw), 'registry.json');
});
els.downloadSearch.addEventListener('click', () => {
  downloadJSON(denormalizeSearch(searchArr, searchRaw), 'search.json');
});
els.downloadCross.addEventListener('click', () => {
  downloadJSON(denormalizeCross(crossObj), 'cross_links.json');
});

// Boot
loadAll().catch(err => {
  els.log.textContent += `\n\n${err.message}\nIf you see NOT_FOUND, verify the three JSONs exist at ${BASE}/ and are served by Vercel (filesystem handler).`;
});
</script>
</body>
</html>
